// Copyright 2017 Palantir Technologies. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package encryption

import (
	"crypto/aes"
	"crypto/cipher"
	"fmt"
)

// AESGCMCipher is a cipher that supports encrypting and decrypting values using AES keys. Uses the specified nonce and
// tag sizes.
type AESGCMCipher struct {
	nonceSizeBytes int
	tagSizeBytes   int
}

const (
	aesGCMDefaultNonceSizeBytes = 12
	aesGCMDefaultTagSizeBytes   = 16
)

// NewAESGCMCipher returns a new Cipher that uses AES with GCM using default parameters (96-bit nonce, 128-bit tag).
func NewAESGCMCipher() *AESGCMCipher {
	return &AESGCMCipher{
		nonceSizeBytes: aesGCMDefaultNonceSizeBytes,
		tagSizeBytes:   aesGCMDefaultTagSizeBytes,
	}
}

// AESGCMCipherWithNonceAndTagSize returns a new Cipher that uses AES with GCM using the specified sizes (in bytes) for
// for the nonce and tag.
func AESGCMCipherWithNonceAndTagSize(nonceSizeBytes, tagSizeBytes int) *AESGCMCipher {
	return &AESGCMCipher{
		nonceSizeBytes: nonceSizeBytes,
		tagSizeBytes:   tagSizeBytes,
	}
}

// Encrypt encrypts the provided value using the specified key. The key must be of type *AESKey. The returned bytes are
// [nonce+ciphertext+tag].
func (a *AESGCMCipher) Encrypt(data []byte, key Key) ([]byte, error) {
	aesKey, ok := key.(*AESKey)
	if !ok {
		return nil, fmt.Errorf("key must be of *AESKey, but was %T", key)
	}

	gcm, err := newBlockCipher(aesKey, a.nonceSizeBytes)
	if err != nil {
		return nil, err
	}

	// generate random nonce/IV
	nonce, err := RandomBytes(gcm.NonceSize())
	if err != nil {
		return nil, fmt.Errorf("failed to generate nonce: %v", err)
	}

	encrypted := gcm.Seal(nil, nonce, data, nil)

	return append(nonce, encrypted...), nil
}

// Parts takes output bytes of the form generated by Encrypt and splits them into the nonce, ciphertext and tag based
// on the parameter values of this cipher.
func (a *AESGCMCipher) Parts(encryptedData []byte) (nonce []byte, ciphertext []byte, tag []byte) {
	return encryptedData[:a.nonceSizeBytes],
		encryptedData[a.nonceSizeBytes : len(encryptedData)-a.tagSizeBytes],
		encryptedData[len(encryptedData)-a.tagSizeBytes:]
}

// Decrypt decrypts the provided value using the specified key. The key must be of type *AESKey. The provided data must
// be of the form [nonce+ciphertext+tag]. Returns the bytes for the decrypted ciphertext (the input originally provided
// to Encrypt).
func (a *AESGCMCipher) Decrypt(data []byte, key Key) ([]byte, error) {
	aesKey, ok := key.(*AESKey)
	if !ok {
		return nil, fmt.Errorf("key must be of type *AESKey, was %T", key)
	}

	gcm, err := newBlockCipher(aesKey, a.nonceSizeBytes)
	if err != nil {
		return nil, err
	}
	plain, err := gcm.Open(nil, data[:a.nonceSizeBytes], data[a.nonceSizeBytes:], nil)
	if err != nil {
		return nil, fmt.Errorf("failed to decrypt value: %v", err)
	}
	return plain, nil
}

func newBlockCipher(key *AESKey, nonceSizeBytes int) (cipher.AEAD, error) {
	block, err := aes.NewCipher(key.key)
	if err != nil {
		return nil, fmt.Errorf("failed to construct AES cipher: %v", err)
	}
	gcm, err := cipher.NewGCMWithNonceSize(block, nonceSizeBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to construct block cipher: %v", err)
	}
	return gcm, nil
}
