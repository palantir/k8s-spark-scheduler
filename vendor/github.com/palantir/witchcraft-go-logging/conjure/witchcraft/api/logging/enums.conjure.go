// This file was generated by Conjure and should not be manually edited.

package logging

import (
	"strings"
)

type AuditResult struct {
	val AuditResult_Value
}

type AuditResult_Value string

const (
	AuditResult_SUCCESS      AuditResult_Value = "SUCCESS"
	AuditResult_UNAUTHORIZED AuditResult_Value = "UNAUTHORIZED"
	AuditResult_ERROR        AuditResult_Value = "ERROR"
	AuditResult_UNKNOWN      AuditResult_Value = "UNKNOWN"
)

// AuditResult_Values returns all known variants of AuditResult.
func AuditResult_Values() []AuditResult_Value {
	return []AuditResult_Value{AuditResult_SUCCESS, AuditResult_UNAUTHORIZED, AuditResult_ERROR}
}

func New_AuditResult(value AuditResult_Value) AuditResult {
	return AuditResult{val: value}
}

// IsUnknown returns false for all known variants of AuditResult and true otherwise.
func (e AuditResult) IsUnknown() bool {
	switch e.val {
	case AuditResult_SUCCESS, AuditResult_UNAUTHORIZED, AuditResult_ERROR:
		return false
	}
	return true
}

func (e AuditResult) Value() AuditResult_Value {
	if e.IsUnknown() {
		return AuditResult_UNKNOWN
	}
	return e.val
}

func (e AuditResult) String() string {
	return string(e.val)
}

func (e AuditResult) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *AuditResult) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_AuditResult(AuditResult_Value(v))
	case "SUCCESS":
		*e = New_AuditResult(AuditResult_SUCCESS)
	case "UNAUTHORIZED":
		*e = New_AuditResult(AuditResult_UNAUTHORIZED)
	case "ERROR":
		*e = New_AuditResult(AuditResult_ERROR)
	}
	return nil
}

type LogLevel struct {
	val LogLevel_Value
}

type LogLevel_Value string

const (
	LogLevel_FATAL   LogLevel_Value = "FATAL"
	LogLevel_ERROR   LogLevel_Value = "ERROR"
	LogLevel_WARN    LogLevel_Value = "WARN"
	LogLevel_INFO    LogLevel_Value = "INFO"
	LogLevel_DEBUG   LogLevel_Value = "DEBUG"
	LogLevel_TRACE   LogLevel_Value = "TRACE"
	LogLevel_UNKNOWN LogLevel_Value = "UNKNOWN"
)

// LogLevel_Values returns all known variants of LogLevel.
func LogLevel_Values() []LogLevel_Value {
	return []LogLevel_Value{LogLevel_FATAL, LogLevel_ERROR, LogLevel_WARN, LogLevel_INFO, LogLevel_DEBUG, LogLevel_TRACE}
}

func New_LogLevel(value LogLevel_Value) LogLevel {
	return LogLevel{val: value}
}

// IsUnknown returns false for all known variants of LogLevel and true otherwise.
func (e LogLevel) IsUnknown() bool {
	switch e.val {
	case LogLevel_FATAL, LogLevel_ERROR, LogLevel_WARN, LogLevel_INFO, LogLevel_DEBUG, LogLevel_TRACE:
		return false
	}
	return true
}

func (e LogLevel) Value() LogLevel_Value {
	if e.IsUnknown() {
		return LogLevel_UNKNOWN
	}
	return e.val
}

func (e LogLevel) String() string {
	return string(e.val)
}

func (e LogLevel) MarshalText() ([]byte, error) {
	return []byte(e.val), nil
}

func (e *LogLevel) UnmarshalText(data []byte) error {
	switch v := strings.ToUpper(string(data)); v {
	default:
		*e = New_LogLevel(LogLevel_Value(v))
	case "FATAL":
		*e = New_LogLevel(LogLevel_FATAL)
	case "ERROR":
		*e = New_LogLevel(LogLevel_ERROR)
	case "WARN":
		*e = New_LogLevel(LogLevel_WARN)
	case "INFO":
		*e = New_LogLevel(LogLevel_INFO)
	case "DEBUG":
		*e = New_LogLevel(LogLevel_DEBUG)
	case "TRACE":
		*e = New_LogLevel(LogLevel_TRACE)
	}
	return nil
}
